++++++++++++++++++++++

여러가지의 정렬 알고리즘이 있지만 기본적인것 5가지만 추려본다.

1. 선택 정렬(Selection Sort) : 현재 위치에 들어갈 값을 찾아 정렬하는 알고리즘이다. 현재 위치에 저장 될 값의 크기가 작냐 크냐에 따라 최소 선택 정렬과 최대 선택 정렬로 구분할 수 있다. 쉽게 말하자면 최소선택정렬은 오름차순, 최대선택정렬은 내림차순으로 정렬하는것을 의미한다.

정렬되지 않은 인덱스의 맨 앞부터 이를 포함한 그 이후의 인덱스들 모두를 순차적으로 조회하는데, 그 값들 중 가장 작은 값(혹은 가장 큰 값)을 찾아 현재 인덱스의 값과 바꿔준다. 나머지 전체의 인덱스들에서도 이러한 과정을 반복해서 실행해준다.

(0번째 인덱스에서 시작해서, 전체 인덱스의 값을 모두 조회, 가장 작은 혹은 큰 값을 찾아 현재 인덱스의 값과 바꿔준다. 이러한 과정을 모든 인덱스에 동일하게 실행시켜서 정렬하는 방법.)

2. 삽입 정렬(Insertion Sort) : 시작을 두번째 인덱스에서 한다. 비교 대상은 현재 인덱스 -1의 인덱스. 이 과정을 전체 인덱스에 진행해준다.

(1번째 인덱스에서 시작해서 1번째 인덱스 -1의 인덱스인 0번째 인덱스와 비교, 현재 인덱스의 값이 더 작으면 현재 인덱스의 값을 비교했던 인덱스의 값으로 저장해주고, 비교인덱스의 -1한 인덱스와 비교를 반복해서 해나간다. 만약 현재 인덱스가 비교 인덱스보다 크다면 비교인덱스 +1을 한 인덱스의 값에 현재 인덱스의 값을 저장해준다. 이런식으로 전체 인덱스에 실행해준다.)

3. 버블 정렬(Bubble Sort) : 시작을 두번째 인덱스에서 한다. 비교는 바로 이전의 인덱스의 값과 비교한다. 만약 오름차순으로 정렬한다고 했을때 바로 이전 인덱스의 값이 현재 인덱스의 값보다 크다면 현재 인덱스와 바꿔준다. 이런식으로 전체인덱스를 1번 실행해주면 가장 큰 값이 맨 뒤로 가게된다. 그렇기때문에 (전체 인덱스의 크기 - 현재까지 순환한 바퀴수)만큼만 반복해주면 정렬이 된다.

(1번째 인덱스에서 시작해 바로 전 인덱스인 0번째 인덱스와 비교해서 위치를 바꿔주고, 이를 전체 인덱스에 실행해준다. 그러면 가장큰값 혹은 가장 작은 값이 맨 뒤에 저장되는데, 나머지 정렬을 위해서 마찬가지로 계속 실행해준다. 최종적으로 정렬이 완성된다.)

4. 합병 정렬(Merge Sort) : 분할과 정복의 방식으로 설계된 알고리즘이다. 분할이라 함은 큰 문제를 반으로 쪼개 문제를 해결해나가는 방식으로 분할은 배열의 크기가 1보다 작거나 같을때까지 계속 반복한다.

(정렬되지 않은 값들이 저장된 배열을 받았다면, 우선 반으로 쪼갠다. 쪼갠 배열을 a와b라고 하자. a와b의 값들을 비교해줘야 하는데 a의 인덱스와 같은 인덱스의 b의 값을 비교해준다. 즉 a의 0번째 인덱스와 b의 0번째 인덱스를 비교해준다. 오름차순이냐 내림차순이냐에 따라 그에 맞는 값을 새로운 배열에 하나씩 넣어주고 이런식으로 전체 인덱스를 조회해가며 합병해나가는 방식으로 정렬한다. 그림으로 보면 이해가 더 빠르다.)

5. 퀼 정렬(Quick Sort) : 역시나 분할과 정복의 방식으로 설계된 알고리즘이다. Pivot Point라고 기준이 되는 값을 하나 설정해서 이 값을 기준으로 작은값은 왼쪽 큰 값은 오른쪽으로 옮기는 방식으로 정렬을 진행한다. 이를 계속 반복해서 분할된 배열의 크기가 1이 되면 배열이 모두 정렬된다.

(Pivot Point를 지정해주고 그것을 기준으로 왼쪽 오른쪽으로 값들을 옮겨준다. 한번 사용했던 Pivot Point값 제외 나머지 2개로 구분된 값들을 사용해 다시 새로 Pivot Point를 지정해주고 왼쪽 오른쪽으로 값들을 옮겨준다. 이를 배열의 값이 1보다 작거나 같을때까지 계속 반복적으로 실행해주면 정렬이 되고 최종적으로 모든 값을 다 합쳐 정렬된 완성 배열을 얻을 수 있게 된다.)

++++++++++++++++++++++
